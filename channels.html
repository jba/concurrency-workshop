<!DOCTYPE html>
<html>
  <head>
    <title>Channels</title>
    <meta charset='utf-8'>
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='static/slides.js'></script>
  </head>

  <body style='display: none'>
    <section class='slides'>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/channels/10/c_test.go -->
<article>
  <h1>Passing a value between goroutines</h1>
  <div class='text'>
<p>We can pass a value between goroutines with a WaitGroup.</p>
  </div>
  <div class='code'><pre>
    var wg sync.WaitGroup
    var v int
    wg.Go(func() { v = compute(7) })
    wg.Wait()
    fmt.Println(v)</pre>
  </div>
  <div class='text'>
<p>But there is a more flexible way: channels.</p>
  </div>
  <span class='pagenumber'>1</span>
</article>
<article>
  <h1>Unbuffered channels</h1>
  <div class='text'>
<ul>
<li>An unbuffered channel lets two goroutines rendezvous.</li>
<li>It doesn't matter which happens first, the send or the receive.</li>
</ul>
  </div>
  <div class='code'><pre>
    ch := make(chan int) <comment>// create a channel</comment>

    go func() { ch &lt;- compute(7) }() <comment>// send to ch</comment>

    v := &lt;-ch <comment>// receive from ch</comment>

    fmt.Println(v)</pre>
  </div>
  <span class='pagenumber'>2</span>
</article>
<article>
  <h1>Multiples</h1>
  <div class='text'>
<p>You can have many senders, and many receivers.</p>
  </div>
  <div class='code'><pre>
    ch := make(chan int)
    for i := range 5 {
        go func() { ch &lt;- compute(i) }()
    }
    for range 5 {
        go func() {
            fmt.Println(&lt;-ch)
        }()
    }
    <comment>// TODO: Wait for all goroutines here.</comment></pre>
  </div>
  <span class='pagenumber'>3</span>
</article>
<article class='problem'>
  <h1>Timeout, v1</h1>
  <div class='text'>
<p>The <code>select</code> statement blocks until one of the cases is ready.</p>
  </div>
  <div class='code'><pre>
    ch := make(chan int)
    timeout := make(chan bool)
    go func() {
        ch &lt;- compute(7)
    }()
    go func() {
        time.Sleep(20 * time.Millisecond)
        timeout &lt;- true
    }()
    select {
    case v := &lt;-ch:
        fmt.Println(v)
    case &lt;-timeout:
        fmt.Println(&#34;timed out&#34;)
    }</pre>
  </div>
  <div class='text'>
<p>We'll get to the problem after the next slide.</p>
  </div>
  <span class='pagenumber'>4</span>
</article>
<article>
  <h1>Timeout, v2</h1>
  <div class='text'>
<p>Use <code>time.After</code> for timeouts.</p>
  </div>
  <div class='code'><pre>
    ch := make(chan int)
    go func() {
        ch &lt;- compute(7)
    }()
    select {
    case v := &lt;-ch:
        fmt.Println(v)
<b>    case &lt;-time.After(20 * time.Millisecond):</b>
        fmt.Println(&#34;timed out&#34;)
    }</pre>
  </div>
  <span class='pagenumber'>5</span>
</article>
<article>
  <h1>Goroutine leaks</h1>
<ul>
<li>What happens to the first goroutine if there is a timeout?</li>
<li>(Assume nothing else receives from <code>ch</code>)</li>
</ul>
  <details><summary></summary>
<ol>
<li><code>time.After</code> case executes</li>
<li><code>select</code> finishes</li>
<li>goroutine tries to send to <code>ch</code></li>
</ol>
<ul>
<li>The GC does not collect <code>ch</code>: there is still a reference to it.</li>
<li>The GC does not collect goroutines: they must terminate.</li>
</ul>
  </details>
  <div class='code'><pre>
    ch := make(chan int)
    go func() {
        ch &lt;- compute(7)
    }()
    select {
    case v := &lt;-ch:
        fmt.Println(v)
<b>    case &lt;-time.After(20 * time.Millisecond):</b>
        fmt.Println(&#34;timed out&#34;)
    }</pre>
  </div>
  <span class='pagenumber'>6</span>
</article>
<article>
  <h1>Buffered goroutines</h1>
  <div class='text'>
<ul>
<li>A channel can have a queue of values.</li>
<li>Sending enqueues, blocks if full.</li>
<li>Receiving dequeues, blocks if empty.</li>
<li>Sender and receiver don't have to rendezvous.</li>
</ul>
  </div>
  <div class='code'><pre>
    ch := make(chan int<b>, 1</b>)
    go func() {
        ch &lt;- compute(7)
    }()
    select {
    case v := &lt;-ch:
        fmt.Println(v)
<b>    case &lt;-time.After(20 * time.Millisecond):</b>
        fmt.Println(&#34;timed out&#34;)
    }</pre>
  </div>
  <div class='text'>
<ol>
<li><code>time.After</code> case executes</li>
<li><code>select</code> finishes</li>
<li>goroutine tries to send to <code>ch</code></li>
<li>value is enqueued</li>
<li>goroutine exits</li>
</ol>
<p>no leaks, no garbage</p>
  </div>
  <span class='pagenumber'>7</span>
</article>
<article>
  <h1>Non-blocking select</h1>
  <div class='text'>
<p>Let's implement this:</p>
  </div>
  <div class='code'><pre>
<comment>// sendNotification optionally sends a notification without</comment>
<comment>// blocking the current goroutine.</comment>
<comment>// To avoid blocking, the notification might be dropped.</comment>
func <defn>sendNotification</defn>(string) {}

<comment>// receiveNotification receives a notification if there is one.</comment>
<comment>// It returns &#34;&#34; if there isn&#39;t.</comment>
<comment>// It never blocks.</comment>
func <defn>receiveNotification</defn>() string { return &#34;&#34; }
</pre>
  </div>
  <span class='pagenumber'>8</span>
</article>
<article>
  <h1>Notifications: first attempt</h1>
  <div class='code'><pre>
var nc = make(chan string)

func <defn>sendNotification</defn>(s string) { nc &lt;- s }

func <defn>receiveNotification</defn>() string { return &lt;-nc }
</pre>
  </div>
  <div class='text'>
<p>WDYT?</p>
  </div>
  <span class='pagenumber'>9</span>
</article>
<article>
  <h1>Notifications: solution</h1>
  <div class='code'><pre>
var nc = make(chan string<b>, 10</b>)

func <defn>sendNotification</defn>(s string) {
<b>    select {
    case nc &lt;- s:
    default: <comment>// if we can&#39;t send, drop s</comment>
    }</b>
}

func <defn>receiveNotification</defn>() string {
<b>    select {
    case s := &lt;-nc:
        return s
    default:
        return &#34;&#34;
    }
}
</pre>
  </div>
  <span class='pagenumber'>10</span>
</article>
<article>
  <h1>Closing channels</h1>
  <div class='text'>
<ul>
<li>Close a channel when it will never be sent to again.</li>
<li>Every receiver is notified.</li>
</ul>
  </div>
  <span class='pagenumber'>11</span>
</article>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>
    <script type="application/javascript" src='static/play.js'></script>
  </body>
</html>
