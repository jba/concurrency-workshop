<!DOCTYPE html>
<html>
  <head>
    <title>Channels</title>
    <meta charset='utf-8'>
    <link rel='icon' type='image/svg+xml' href='static/favicon.svg'>
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='static/slides.js'></script>
  </head>

  <body style='display: none'>
    <section class='slides'>
<article class='title-slide'>
  <div class='title-text'>Channels</div>
</article>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/channels/10/c_test.go -->
<article>
  <h1>Passing a value between goroutines</h1>
  <div class='text'>
<p>We can pass a value between goroutines with a <code>WaitGroup</code>.</p>
  </div>
  <div class='code'><pre>
var wg sync.WaitGroup
var v int
wg.Go(func() { v = compute(7) })
wg.Wait()
fmt.Println(v)</pre>
  </div>
  <div class='text'>
<p>But there is a more flexible way: channels.</p>
  </div>
  <span class='pagenumber'>2</span>
</article>
<article>
  <h1>Unbuffered channels</h1>
  <div class='text'>
<p>An unbuffered channel lets two goroutines rendezvous.</p>
  </div>
  <div class='code'><pre>
c := make(chan int) <comment>// create a channel</comment>

go func() { c &lt;- compute(7) }() <comment>// send to c</comment>

v := &lt;-c <comment>// receive from c</comment>

fmt.Println(v)</pre>
  </div>
  <div class='text'>
<p>It doesn't matter which happens first, the send or the receive.</p>
  </div>
  <span class='pagenumber'>3</span>
</article>
<article>
  <h1>Multiples</h1>
  <div class='text'>
<p>You can have many senders, and many receivers.</p>
  </div>
  <div class='code'><pre>
c := make(chan int)
for i := range 5 {
    go func() { c &lt;- compute(i) }()
}
for range 5 {
    go func() {
        fmt.Println(&lt;-c)
    }()
}
<comment>// Wait for all goroutines here.</comment></pre>
  </div>
  <span class='pagenumber'>4</span>
</article>
<article>
  <h1>Timeout, v1</h1>
  <div class='text'>
<p>The <code>select</code> statement blocks until one of the cases is ready.</p>
  </div>
  <div class='code bad'><pre>
c := make(chan int)
timeout := make(chan bool)
go func() { c &lt;- compute(7) }()
go func() {
    time.Sleep(20 * time.Millisecond)
    timeout &lt;- true
}()
select {
case v := &lt;-c:
    fmt.Println(v)
case &lt;-timeout:
    fmt.Println(&#34;timed out&#34;)
}</pre>
  </div>
  <div class='text'>
<p>We'll get to the problem after the next slide.</p>
  </div>
  <span class='pagenumber'>5</span>
</article>
<article>
  <h1>Timeout, v2</h1>
  <div class='text'>
<p>Use <code>time.After</code> for timeouts.</p>
  </div>
  <div class='code'><pre>
c := make(chan int)
go func() { c &lt;- compute(7) }()
select {
case v := &lt;-c:
    fmt.Println(v)
<span class="em">case &lt;-time.After(20 * time.Millisecond):</span>
    fmt.Println(&#34;timed out&#34;)
}</pre>
  </div>
  <span class='pagenumber'>6</span>
</article>
<article>
  <h1>Goroutine leaks</h1>
  <div class="flex"><div>
  <div class='code bad'><pre>
c := make(chan int)
go func() { c &lt;- compute(7) }()
select {
case v := &lt;-c:
    fmt.Println(v)
case &lt;-time.After(20 * time.Millisecond):
    fmt.Println(&#34;timed out&#34;)
}
<comment>// program continues</comment></pre>
  </div>
  </div><div>
<p>What happens to the first goroutine if there is a timeout?</p>
  <details><summary></summary>
<ol>
<li><code>time.After</code> case executes</li>
<li><code>select</code> finishes</li>
<li>goroutine tries to send to <code>c</code></li>
</ol>
<ul>
<li>The GC does not collect <code>c</code>: there is still a reference to it.</li>
<li>The GC does not collect goroutines: they must terminate.</li>
</ul>
  </details>
  </div></div> <!-- flex -->
  <span class='pagenumber'>7</span>
</article>
<article>
  <h1>Buffered goroutines</h1>
  <div class="flex"><div>
  <div class='code'><pre>
c := make(chan int<span class="em">, 1</span>)
go func() { c &lt;- compute(7) }()
select {
case v := &lt;-c:
    fmt.Println(v)
case &lt;-time.After(20 * time.Millisecond):
    fmt.Println(&#34;timed out&#34;)
}
<comment>// program continues</comment></pre>
  </div>
  <div class='text'>
<ul>
<li>A channel can have a queue of values.</li>
<li>Sending enqueues, blocks if full.</li>
<li>Receiving dequeues, blocks if empty.</li>
<li>Sender and receiver don't have to rendezvous.</li>
</ul>
  </div>
  </div><div>
<p>And now?</p>
  <details><summary></summary>
<ol>
<li><code>time.After</code> case executes</li>
<li><code>select</code> finishes</li>
<li>goroutine tries to send to <code>c</code></li>
<li><span style="color:purple">value is enqueued</span></li>
<li>goroutine exits</li>
</ol>
<p>no leaks, no garbage</p>
  </details>
  </div></div> <!-- flex -->
  <span class='pagenumber'>8</span>
</article>
<article>
  <h1>Non-blocking select</h1>
  <div class='text'>
<p>Let's implement this:</p>
  </div>
  <div class='code'><pre>
<comment>// sendNotification optionally sends a notification without</comment>
<comment>// blocking the current goroutine.</comment>
<comment>// To avoid blocking, the notification might be dropped.</comment>
func <defn>sendNotification</defn>(string) {}

<comment>// receiveNotification receives a notification if there is one.</comment>
<comment>// It returns &#34;&#34; if there isn&#39;t.</comment>
<comment>// It never blocks.</comment>
func <defn>receiveNotification</defn>() string { return &#34;&#34; }
</pre>
  </div>
  <span class='pagenumber'>9</span>
</article>
<article>
  <h1>Notifications: first attempt</h1>
  <div class='code'><pre>
var nc = make(chan string)

func <defn>sendNotification</defn>(s string) { nc &lt;- s }

func <defn>receiveNotification</defn>() string { return &lt;-nc }
</pre>
  </div>
  <div class='text'>
<p>What happens here?</p>
  </div>
  <div class='text'>
<p>What if we add buffering?</p>
  </div>
  <span class='pagenumber'>10</span>
</article>
<article>
  <h1>Notifications: solution</h1>
  <div class='code'><pre>
var nc = make(chan string<span class="em">, 10</span>)

func <defn>sendNotification</defn>(s string) {
<span class="em">    select {
    case nc &lt;- s:
    default: <comment>// if we can&#39;t send, drop s</comment>
    }</span>
}

func <defn>receiveNotification</defn>() string {
<span class="em">    select {
    case s := &lt;-nc:
        return s
    default:
        return &#34;&#34;
    }
}
</pre>
  </div>
  <span class='pagenumber'>11</span>
</article>
<article>
  <h1>Closing channels</h1>
  <div class='text'>
<ul>
<li>Close a channel when it will never be sent to again.</li>
<li>Every receiver is notified.</li>
</ul>
  </div>
  <div class="flex"><div>
  <div class='code bad'><pre>
type <defn>node</defn> struct {
    val         int
    left, right *node
}

func <defn>sendValues</defn>(n *node, ch chan int) {
    if n == nil {
        return
    }
    sendValues(n.left, ch)
    ch &lt;- n.val
    sendValues(n.right, ch)
}
</pre>
  </div>
  </div><div>
  <div class='code'><pre>
func <defn>printTree</defn>(root *node) {
    c := make(chan int)
    go func() {
        sendValues(root, c)
<span class="em">        close(c)</span>
    }()

    for {
        v, <span class="em">ok</span> := &lt;-c
        if !ok {     <comment>// c is closed</comment>
            break
        }
        fmt.Println(v)
    }
}
</pre>
  </div>
  </div></div> <!-- flex -->
  <span class='pagenumber'>12</span>
</article>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>
    <script type="application/javascript" src='static/play.js'></script>
  </body>
</html>
