<!DOCTYPE html>
<html>
  <head>
    <title>WG</title>
    <meta charset='utf-8'>
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='static/slides.js'></script>
  </head>

  <body style='display: none'>
    <section class='slides'>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/waitgroup/1/wg.go -->
<article>
  <h1>Implementing WaitGroup</h1>
  <div class="flex">
  <div class='code'><pre>
type <defn>WaitGroup</defn> struct {
    count int <comment>// number of active goroutines</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.Add(1)
    go func() {
        defer g.Done()
        f()
    }()
}

func (g *WaitGroup) <defn>Add</defn>(n int) {
    g.count += n
}

func (g *WaitGroup) <defn>Done</defn>() { g.Add(-1) }

func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// Wait for g.count to reach 0.</comment>
}
</pre>
  </div>
  <div> <!-- one child for flex -->
  <div style="height: 5em"></div>
  <div class='text'>
<p>See <a href="https://go-review.git.corp.google.com/c/go/+/717760">this CL</a>
for a recent, subtle change to <code>Go</code>.</p>
  </div>
  <div style="height: 5em"></div>
<p>Any thoughts about how we're using <code>count</code>?</p>
  <details><summary></summary>
<p>The problem is that there is no synchronization.
<code>Go</code> should be goroutine-safe.</p>
  </details>
  </div>
  </div> <!-- flex -->
  <span class='pagenumber'>1</span>
</article>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/waitgroup/2/wg.go -->
<article>
  <h1>WaitGroup with a mutex</h1>
  <div class='code'><pre>
type <defn>WaitGroup</defn> struct {
<b>    mu sync.Mutex</b>
    count int <comment>// number of active goroutines</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.Add(1)
    go func() {
        defer g.Done()
        f()
    }()
}

<b>func (g *WaitGroup) <defn>Add</defn>(n int) {
    g.mu.Lock()
    defer g.mu.Unlock()
    g.count += n
}
</b>

func (g *WaitGroup) <defn>Done</defn>() { g.Add(-1) }

func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// Wait for g.count to reach 0.</comment>
}
</pre>
  </div>
  <span class='pagenumber'>2</span>
</article>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/waitgroup/3/wg.go -->
<article>
  <h1>WaitGroup with atomics</h1>
  <div class="flex">
  <div class='code'><pre>
type <defn>WaitGroup</defn> struct {
<b>    count atomic.Int64 <comment>// number of active goroutines</b></comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.Add(1)
    go func() {
        defer g.Add(-1)
        f()
    }()
}

<b>func (g *WaitGroup) <defn>Add</defn>(n int) {
    g.count.Add(int64(n))
}
</b>

func (g *WaitGroup) <defn>Done</defn>() { g.Add(-1) }

func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// Wait for g.count to reach 0.</comment>
}
</pre>
  </div>
  <div class='text'>
<p>Atomics work well here, for now</p>
<p>Stdlib implementation uses them</p>
  </div>
  </div> <!-- flex -->
  <span class='pagenumber'>3</span>
</article>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/waitgroup/4/wg.go -->
<article>
  <h1>The Wait method</h1>
  <div class="flex">
  <div class='code'><pre>
type <defn>WaitGroup</defn> struct {
    count atomic.Int64 <comment>// number of active goroutines</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.Add(1)
    go func() {
        defer g.Add(-1)
        f()
    }()
}

func (g *WaitGroup) <defn>Add</defn>(n int) {
    g.count.Add(int64(n))
}

func (g *WaitGroup) <defn>Done</defn>() { g.Add(-1) }

<b>func (g *WaitGroup) <defn>Wait</defn>() {
    for g.count.Load() &gt; 0 {
        time.Sleep(time.Millisecond)
    }
}
</b></pre>
  </div>
  <div> <!-- one child for flex -->
<p>What's wrong with busy-waiting?</p>
  <details><summary></summary>
<ul>
<li>Sleep too long: waste time</li>
<li>Sleep too short: waste CPU</li>
</ul>
  </details>
<p>Find the bug.</p>
  <details><summary></summary>
<p><code>Wait</code> might not notice a 0 count.</p>
<div class="interleave" style="font-size: 70%">
<table>
<thead>
<tr>
<th>G1</th>
<th>G2</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>Add(1)</td>
</tr>
<tr>
<td>Load</td>
<td></td>
</tr>
<tr>
<td>Sleep</td>
<td></td>
</tr>
<tr>
<td></td>
<td>Done()</td>
</tr>
<tr>
<td></td>
<td>Add(1)</td>
</tr>
<tr>
<td>Load</td>
<td></td>
</tr>
<tr>
<td>Sleep</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div style="font-size: 50%">
(Technically, this is disallowed:
"Note that calls with a positive delta that occur when the counter is zero must happen before a Wait.")
</div>
  </details>
  </div>
  </div> <!-- flex -->
  <span class='pagenumber'>4</span>
</article>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/waitgroup/5/wg.go -->
<article>
  <h1>Fixing busy-waiting Wait</h1>
  <div class='text'>
<ul>
<li>Use a channel</li>
<li>Close it to broadcast</li>
</ul>
  </div>
  <div class="flex">
  <div class='code'><pre>
type <defn>WaitGroup</defn> struct {
    count atomic.Int64 <comment>// number of active goroutines</comment>
<b>    done chan struct{} <comment>// closed when count reaches zero</b></comment>
}

<b>func <defn>NewWaitGroup</defn>() *WaitGroup {
    return &amp;WaitGroup{done: make(chan struct{})}
}
</b>
func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.add(1)
    go func() {
        defer g.add(-1)
        f()
    }()
}
</pre>
  </div>
  <div class='code'><pre>
func (g *WaitGroup) <defn>add</defn>(n int) {
    c := g.count.Add(int64(n))
<b>    if c == 0 {
        close(g.done)
    }</b>
}

func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// In-class exercise: what goes here?</comment>
}
</pre>
  </div>
  </div> <!-- flex -->
<p>What should the body of Wait be?</p>
  <details><summary></summary>
<p><code>&lt;-g.done</code>
That's it!</p>
  </details>
<p>Find the bug in <code>add</code>.</p>
  <details><summary></summary>
<p>Two goroutines may both end up on <code>if c == 0</code> with c == 0.
(How?)
Closing a channel for a second time panics.</p>
  </details>
  <span class='pagenumber'>5</span>
</article>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/waitgroup/6/wg.go -->
<article>
  <h1>Back to a mutex</h1>
  <div class='text'>
<p>Need a mutex to perform more than one operation atomically</p>
  </div>
  <div class="flex">
  <div class='code'><pre>
type <defn>WaitGroup</defn> struct {
    mu    sync.Mutex
    count int           <comment>// number of active goroutines</comment>
    done  chan struct{} <comment>// closed when count reaches zero</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.add(1)
    go func() {
        defer g.add(-1)
        f()
    }()
}
</pre>
  </div>
  <div class='code'><pre>
<b>func (g *WaitGroup) <defn>add</defn>(n int) {
    g.mu.Lock()
    defer g.mu.Unlock()
    if g.done == nil {
        g.done = make(chan struct{})
    }
    g.count += n
    if g.count == 0 {
        close(g.done)
        g.done = nil <comment>// don&#39;t close channel twice</comment>
    }
}
</b>
func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// wait for close</comment>
    &lt;-g.done
}
</pre>
  </div>
  </div> <!-- flex -->
<p>Find the race condition.</p>
  <details><summary></summary>
<p>Wait reads <code>g.done</code> without the lock.</p>
  </details>
<p>This WaitGroup can't be used for a second wave of <code>Go</code> calls: once the first
group of goroutines completes, the channel is nil, and <code>Wait</code> will never return.</p>
<p>How can we fix that?</p>
  <details><summary></summary>
<p>TODO</p>
  </details>
  <span class='pagenumber'>6</span>
</article>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/waitgroup/7/wg.go -->
<article>
  <h1>Fixing the race</h1>
  <div class='text'>
<ul>
<li>Channel <em>operations</em> are concurrency-safe</li>
<li>But <em>accessing a variable</em> (even one holding a channel) is not</li>
</ul>
  </div>
  <div class="flex">
  <div class='code'><pre>
type <defn>WaitGroup</defn> struct {
    mu    sync.Mutex
    count int           <comment>// number of active goroutines</comment>
    done  chan struct{} <comment>// closed when count reaches zero</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.add(1)
    go func() {
        defer g.add(-1)
        f()
    }()
}
</pre>
  </div>
  <div class='code'><pre>
func (g *WaitGroup) <defn>add</defn>(n int) {
    g.mu.Lock()
    defer g.mu.Unlock()
    if g.done == nil {
        g.done = make(chan struct{})
    }
    g.count += n
    if g.count == 0 {
        close(g.done)
        g.done = nil <comment>// Make sure we only close this channel once.</comment>
    }
}

<b>func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// Wait for something to be written to the channel, or for it to be closed.</comment>
    g.mu.Lock()
    defer g.mu.Unlock()
    &lt;-g.done
}
</b></pre>
  </div>
  </div> <!-- flex -->
<p>Find the bug.</p>
  <details><summary></summary>
<p><code>Wait</code> holds the mutex while it's waiting, so <code>add</code> can't run to decrement the counter.</p>
  </details>
  <span class='pagenumber'>7</span>
</article>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/waitgroup/8/wg.go -->
<article>
  <h1>Fix to previous</h1>
  <div class='text'>
<ul>
<li>Channel <em>operations</em> are concurrency-safe</li>
<li>But <em>accessing a variable</em> (even one holding a channel) is not</li>
</ul>
  </div>
  <div class='code'><pre>
type <defn>WaitGroup</defn> struct {
    mu    sync.Mutex
    count int           <comment>// number of active goroutines</comment>
    done  chan struct{} <comment>// closed when count reaches zero</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.add(1)
    go func() {
        defer g.add(-1)
        f()
    }()
}

func (g *WaitGroup) <defn>add</defn>(n int) {
    g.mu.Lock()
    defer g.mu.Unlock()
    if g.done == nil {
        g.done = make(chan struct{})
    }
    g.count += n
    if g.count == 0 {
        close(g.done)
        g.done = nil <comment>// Make sure we only close this channel once.</comment>
    }
}

func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// Wait for something to be written to the channel, or for it to be closed.</comment>
<b>    g.mu.Lock()
    d := g.done
    g.mu.Unlock()</b>
    &lt;-d
}
</pre>
  </div>
  <span class='pagenumber'>8</span>
</article>

<!-- /usr/local/google/home/jba/repos/github.com/jba/concurrency-workshop/slides/waitgroup/9/wg.go -->
<article>
  <h1>The real thing</h1>
  <div class='text'>
<p>Actual sync.WaitGroup implementation</p>
  </div>
  <span class='pagenumber'>9</span>
</article>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>
    <script type="application/javascript" src='static/play.js'></script>
  </body>
</html>
