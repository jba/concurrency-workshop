<!DOCTYPE html>
<html>
  <head>
    <title>WG</title>
    <meta charset='utf-8'>
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='/static/slides.js'></script>
  </head>

  <body style='display: none'>
    <section class='slides'>
<article>
  <h1>Implementing WaitGroup</h1>
    <div class='code'><pre>type <defn>WaitGroup</defn> struct {
    count int <comment>// number of active goroutines</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.add(1)
    go func() {
        defer g.add(-1)
        f()
    }()
}

func (g *WaitGroup) <defn>add</defn>(n int) {
    g.count += n
}

func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// Wait for g.count to reach 0.</comment>
}

</pre></div>
<p>Thoughts?</p>
  <details><summary></summary>
<p>The problem is that there is no synchronization.
<code>Go</code> should be goroutine-safe.</p>
  </details>
<span class='pagenumber'>0</span>
</article>
<article>
  <h1>WaitGroup with a mutex</h1>
    <div class='code'><pre>type <defn>WaitGroup</defn> struct {
<b>    mu sync.Mutex
</b>    count int <comment>// number of active goroutines</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.add(1)
    go func() {
        defer g.add(-1)
        f()
    }()
}

<b>func (g *WaitGroup) <defn>add</defn>(n int) {
    g.mu.Lock()
    defer g.mu.Unlock()
    g.count += n
}

</b>
func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// Wait for g.count to reach 0.</comment>
}

</pre></div>
<span class='pagenumber'>1</span>
</article>
<article>
  <h1>Aside: Atomics</h1>
    <div class='code'><pre>type <defn>WaitGroup</defn> struct {
<b>    count atomic.Int64 <comment>// number of active goroutines</comment>
</b>}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.add(1)
    go func() {
        defer g.add(-1)
        f()
    }()
}

<b>func (g *WaitGroup) <defn>add</defn>(n int) {
    g.count.Add(int64(n))
}

</b>
func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// Wait for g.count to reach 0.</comment>
}

</pre></div>
<span class='pagenumber'>2</span>
</article>
<article>
  <h1>The Wait method</h1>
    <div class='code'><pre>type <defn>WaitGroup</defn> struct {
    count atomic.Int64 <comment>// number of active goroutines</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.add(1)
    go func() {
        defer g.add(-1)
        f()
    }()
}

func (g *WaitGroup) <defn>add</defn>(n int) {
    g.count.Add(int64(n))
}

<b>func (g *WaitGroup) <defn>Wait</defn>() {
    for g.count.Load() &gt; 0 {
        time.Sleep(time.Millisecond)
    }
}

</b>
</pre></div>
<p>What's wrong with busy-waiting?</p>
  <details><summary></summary>
<p>There's no perfect time to sleep. You may sleep too long, wasting time,
or too short, wasting CPU.</p>
  </details>
<p>Find the bug (if any).</p>
  <details><summary></summary>
<p>The count can go to 0, then back up, and Wait won't notice.</p>
  </details>
<span class='pagenumber'>3</span>
</article>
<article>
  <h1>Fixing busy-waiting Wait</h1>
    <div class='code'><pre>func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// In-class exercise: what goes here?</comment>
}

</pre></div>
<p>What should the body of Wait be?</p>
  <details><summary></summary>
<p><code>&lt;-g.done</code>
That's it!</p>
  </details>
<p>There is a subtle bug in <code>add</code>. Find it.</p>
  <details><summary></summary>
<p>Two goroutines may both end up on <code>if c == 0</code> with c == 0.
(How?)
Closing a channel for a second time panics.</p>
  </details>
<span class='pagenumber'>4</span>
</article>
<article>
  <h1>Back to a mutex</h1>
<p>Need a mutex to perform more than one operation atomically</p>
<p>Find the bug.</p>
  <details><summary></summary>
<p>Wait reads <code>g.done</code> without the lock.</p>
  </details>
<p>This WaitGroup can't be used for a second wave of <code>Go</code> calls: once the first
group of goroutines completes, the channel is nil, and <code>Wait</code> will never return
(https://go.dev/ref/spec#Receive_operator:
&quot;Receiving from a nil channel blocks forever.&quot;)</p>
  <details><summary></summary>
<p>How can we fix that?</p>
  <details><summary></summary>
<p>TODO</p>
  </details>
<span class='pagenumber'>5</span>
</article>
<article>
  <h1>wg.go</h1>
<ul>
<li>Channel <em>operations</em> are concurrency-safe</li>
<li>But <em>accessing a variable</em> (even one holding a channel) is not</li>
</ul>
<p>Find the bug.</p>
  <details><summary></summary>
<p><code>Wait</code> holds the mutex while it's waiting, so <code>add</code> can't run to decrement the counter.</p>
  </details>
<span class='pagenumber'>6</span>
</article>
<article>
  <h1>Fix to previous</h1>
<ul>
<li>Channel <em>operations</em> are concurrency-safe</li>
<li>But <em>accessing a variable</em> (even one holding a channel) is not</li>
</ul>
    <div class='code'><pre>type <defn>WaitGroup</defn> struct {
    mu    sync.Mutex
    count int           <comment>// number of active goroutines</comment>
    done  chan struct{} <comment>// closed when count reaches zero</comment>
}

func (g *WaitGroup) <defn>Go</defn>(f func()) {
    g.add(1)
    go func() {
        defer g.add(-1)
        f()
    }()
}

func (g *WaitGroup) <defn>add</defn>(n int) {
    g.mu.Lock()
    defer g.mu.Unlock()
    if g.done == nil {
        g.done = make(chan struct{})
    }
    g.count += n
    if g.count == 0 {
        close(g.done)
        g.done = nil <comment>// Make sure we only close this channel once.</comment>
    }
}

func (g *WaitGroup) <defn>Wait</defn>() {
    <comment>// Wait for something to be written to the channel, or for it to be closed.</comment>
<b>    g.mu.Lock()
    d := g.done
    g.mu.Unlock()
</b>    &lt;-d
}

</pre></div>
<span class='pagenumber'>7</span>
</article>
<article>
  <h1>The real thing</h1>
<p>Actual sync.WaitGroup implementation</p>
<span class='pagenumber'>8</span>
</article>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>
    <script type="application/javascript" src='static/play.js'></script>
  </body>
</html>
